# 数据类型

与其他编程语言类似，Move内置了许多基本类型，包括：

- bool：布尔类型（boolean）；
- 无符号整数（unsigned integer）；
- address：地址类型。

在讨论类型之前，我们首先看看如何在Move中使用变量。

一个变量由`let`关键字声明，默认情况下，使用`let`声明的变量是不可变的。如果要使变量能被修改，可以用`let mut`声明：

```
let a = 123; // a不可变
a = 456; // error!
let mut b = 123; // b可变
b = 456; // ok
```

声明变量时，可以指定变量类型。如果没有指定，那么编译器会根据对变量的赋值自动推断：

```
let x: bool = true; // x为bool类型
let y = true; // y自动推断为bool
```

## 变量隐藏

同一个变量，可以重新声明：

```
let x: u32 = 123; // x类型为u32
let x: bool = true; // x类型为bool
```

重新声明一个变量后，实际上并不是改变原有的变量，而是原有的变量被“隐藏”了，新的变量仅仅是名字与原变量相同。

## 布尔类型

布尔类型（boolean）仅有true、false两个值。声明布尔类型的变量不需要指定类型，因为编译器可以轻松根据赋值来推断类型：

```
let b = true; // b是布尔类型
```

### 无符号整数类型

Move支持多种无符号整数类型，范围从8位（1个字节）到256位（32字节），包括：

- u8：8位无符号整数，范围是0~255；
- u16：16位无符号整数，范围是0~65535；
- u32：32位无符号整数，范围是0~2<sup>32</sup>-1（约42.9亿）；
- u64：64位无符号整数，范围是0~2<sup>64</sup>-1；
- u128：128位无符号整数，范围是0~2<sup>128</sup>-1；
- u256：256位无符号整数，范围是0~2<sup>256</sup>-1；

声明整型时，编译器会根据赋值推断为合适的类型，通常默认是`u64`。不过，可以在声明时显式指定类型：

```
let x: u8 = 123; // x的类型为u8
```

也可以通过常量+后缀的方式来告诉编译器应该推断的类型。以下两种写法是等价的：

```
let x: u8 = 123; // x的类型为u8
let y = 123u8; // y的类型推断为u8
```

## 运算

对整型可以进行加、减、乘、除和求余的运算：

```
let x = a + b;
let y = a / b; // a÷b的整数商
let z = a % b; // a÷b的余数
```

对于整数运算，结果仍为整数。如果计算结果超出了范围，或者除数为0，运算将报错，因此，不必担心计算结果错误，因为Move内置了计算错误检测，计算出错时，整个交易都因错误而回滚。

需要特别注意的是，整数运算的两个操作数必须为同样大小的类型，不同类型不能直接计算，必须首先将其转换为相同类型，这一点与常用的编程语言具有隐式转换不同：

```
let a:u8 = 123;
let b:u32 = 456;
let x = a + b; // 错误！u8不能与u32进行运算
```

可以用`as`将一种整型转换为另一种整型：

```
let a:u8 = 123;
let b:u32 = 456;
let x = (a as u32) + b; // a首先被转型为u32,计算结果为u32
```

如果将上述代码改为：

```
let a:u8 = 123;
let b:u32 = 456;
let x = a + (b as u8); // b首先被转型为u8,计算结果为u8
```

则`b`转型失败，因为超出了`u8`的范围。

可以用按位与运算`&`将`b`的值转换为合适的范围内：

```
let a:u8 = 123;
let b:u32 = 456;
let x = a + ((b & 0xff) as u8);
```

上述代码对`b`的转型是正确的，但仍然会报错，原因是`u8+u8`的加法计算溢出。可见，Move对于任何可能出错的计算都会检查，这保证了计算结果的正确性，避免了任何潜在的因溢出造成的安全漏洞。

## 地址类型

为了表示地址，Move使用一种称为`address`的特殊类型。地址是一个32字节的值，可用于表示区块链上的任何地址。地址有两种语法形式使用，一种是以`0x`为前缀的十六进制地址：

```
let addr1: address = @0xa1b2c3;
```

另一种是命名地址：

```
let addr2 = @alice;
```

命名地址最终需要被转换为指定的地址，因此，Move编译器在看到命名地址时，会在`Move.toml`中查找对应的地址，并替换为实际地址：

```toml
...

[addresses]
alice = "0xf1e2d3c00000000"
```

如果在`Move.toml`文件中找不到代码中使用的命名地址，编译器将报错。

## 地址转换

地址本身虽然以`0x`开头的最多64个字符表示，但地址实际上是一个`u256`的整型。可以用一些辅助函数来处理地址：

```
use sui:address;

let addr1 = @0xa1b2c3;
let addr1_as_u256: u256 = address::to_u256(addr1);
let addr2: address = address::from_u256(0xa1b2c3u256);
```

上述代码实现了`address`类型和`u256`类型的相互转换。此外，地址还可以与`vector<u8>`类型相互转换，`vector`类型相当于其他编程语言中的数组：

```
use sui::address;

let addr1 = @0xa1b2c3;
let addr1_as_vec: vector<u8> = address::to_bytes(addr1);
let addr2: address = address::from_bytes(addr1_as_vec);
```

存储`u8`的`vector`类型`vector<u8>`在Move中可以被视为若干个字节，或者以UTF-8编码的字符串：

```
let x: vector<u8> = vector[0x68, 0x65, 0x6c, 0x6c, 0x6f];
let y: vector<u8> = x"68656c6c6f";
let z: vector<u8> = b"hello";
```

上述三种方式声明的`vector<u8>`内容实际上都是一样的，即UTF-8字符串`hello`。
