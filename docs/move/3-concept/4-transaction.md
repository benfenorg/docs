# 交易

交易是改变区块链状态的唯一方法。在BenFen中，交易可以调用包的函数，部署一个新包，以及升级现有的包。

## 交易结构

一个完整的交易包括：

- 发送者（Sender）：签署交易的帐户；
- 命令列表：待执行的一系列操作；
- 命令输入：待执行命令的参数：
  - pure：简单的值，如数字或字符串；
  - object：执行交易需要访问的对象。
- Gas对象：用于支付交易费用的Coin对象；
- Gas价格和预算：指定交易的Gas价格和预算。

## 输入

交易的输入实际上就是交易的参数，它分为两种类型：

- 纯参数：这些大多是原始类型，包括：
  - `bool`
  - 无符号整数（`u8`，`u16`，`u32`，`u64`，`u128`，`u256`）
  - `address`
  - `std::string::String`：UTF-8编码的字符串
  - `std::ascii::String`：ASCII编码的字符串
  - `vector<T>`：`T`为基本类型的向量
  - `std::option::Option<T>`：`T`为基本类型的Option对象
  - `std::object::ID`：对象的ID
- Object参数：这些是交易将要访问的对象或对象的引用。为了使交易成功执行，对象参数必须是共享对象、冻结对象或交易发送者拥有的对象。

## 命令

一个交易可以由多个命令组成，一个命令可以是一个内置命令（例如发布包），或对已发布包的函数的调用。命令按照它们在事务中列出的顺序依次执行，并且它们可以使用先前命令的结果，形成一条执行链。

仅当一个交易的所有命令全部成功后，这个交易才是成功的。如果任何一个命令执行失败，则交易作为整体失败，所有已执行命令均撤销，这类似数据库事务。

从理论上来说，一个交易可以如下所示（伪代码）：

```plain
Inputs:
- sender = 0xa11ce

Commands:
- payment = SplitCoins(Gas, [ 1000 ])
- item = MoveCall(0xAAA::market::purchase, [ payment ])
- TransferObjects(item, sender)
```

在上面的这个交易示例中，一共包含三个命令：

- `SplitCoins`：这是一个内置命令，此处用于从传入的Gas对象中分割出新的Coin；
- `MoveCall`：调用Move函数，此处是调用包`0xAAA`的`purchase`函数，并给定参数为`payment`对象；
- `TransferObjects`：将对象转移给指定接收者的内置命令。

## 交易结果

一个交易的结果是该交易对区块链状态所做的改变。更具体地说，交易可以通过以下方式更改链的状态：

- 使用Gas对象来支付交易费用；
- 创建、更新或删除对象；
- 发出事件。

交易的执行结果由以下不同部分组成：

- 交易摘要（Digest）：交易的哈希值，用于唯一识别交易；
- 交易数据：交易中使用的输入、命令和Gas对象；
- 交易结果：交易的状态和效果，更具体地说，包括了交易的状态、对象及其版本的更新、使用的Gas对象、交易的Gas成本以及交易发出的事件；
- 事件（Event）：交易中发出的自定义事件；
- 已更改的对象：交易可能对某些对象做出更改，包括所有权的更改；
- 余额变化：交易涉及的账户总余额的变化。
